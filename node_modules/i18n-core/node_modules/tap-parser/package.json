{
  "_args": [
    [
      {
        "raw": "tap-parser@https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
        "scope": null,
        "escapedName": "tap-parser",
        "name": "tap-parser",
        "rawSpec": "https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
        "spec": "https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
        "type": "remote"
      },
      "F:\\JavaScriptcode\\node.js\\learn nodejs\\learnyounode\\node_modules\\i18n-core"
    ]
  ],
  "_from": "tap-parser@>=4.2.2 <5.0.0",
  "_id": "tap-parser@4.2.4",
  "_inCache": true,
  "_location": "/i18n-core/tap-parser",
  "_phantomChildren": {},
  "_requested": {
    "raw": "tap-parser@https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
    "scope": null,
    "escapedName": "tap-parser",
    "name": "tap-parser",
    "rawSpec": "https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
    "spec": "https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/i18n-core",
    "/i18n-core/tap"
  ],
  "_resolved": "https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
  "_shasum": "65a2a602e49e17db83fa1f295f53fad03025cc4d",
  "_shrinkwrap": null,
  "_spec": "tap-parser@https://registry.npmjs.org/tap-parser/-/tap-parser-4.2.4.tgz",
  "_where": "F:\\JavaScriptcode\\node.js\\learn nodejs\\learnyounode\\node_modules\\i18n-core",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "bin": {
    "tap-parser": "bin/cmd.js"
  },
  "bugs": {
    "url": "https://github.com/substack/tap-parser/issues"
  },
  "dependencies": {
    "events-to-array": "^1.0.1",
    "js-yaml": "^3.2.7",
    "readable-stream": "^2"
  },
  "description": "parse the test anything protocol",
  "devDependencies": {
    "glob": "^7.0.5",
    "tap": "^8.0.1"
  },
  "files": [
    "index.js",
    "bin/cmd.js",
    "bin/usage.txt"
  ],
  "homepage": "https://github.com/substack/tap-parser",
  "keywords": [
    "tap",
    "test",
    "parser"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "tap-parser",
  "optionalDependencies": {
    "readable-stream": "^2"
  },
  "readme": "# tap-parser\n\nparse the [test anything protocol](http://testanything.org/)\n\n[![build status](https://secure.travis-ci.org/tapjs/tap-parser.png)](http://travis-ci.org/tapjs/tap-parser)\n\n[![browser support](http://ci.testling.com/substack/tap-parser.png)](http://ci.testling.com/substack/tap-parser)\n\n[![coverage status](https://coveralls.io/repos/tapjs/tap-parser/badge.svg?branch=master&service=github)](https://coveralls.io/github/tapjs/tap-parser?branch=master)\n\n# example\n\n``` js\nvar parser = require('tap-parser');\nvar p = parser(function (results) {\n    console.dir(results);\n});\n\nprocess.stdin.pipe(p);\n```\n\ngiven some [TAP](http://testanything.org/)-formatted input:\n\n```\n$ node test.js\nTAP version 13\n# beep\nok 1 should be equal\nok 2 should be equivalent\n# boop\nok 3 should be equal\nok 4 (unnamed assert)\n\n1..4\n# tests 4\n# pass  4\n\n# ok\n```\n\nparse the output:\n\n```\n$ node test.js | node parse.js\n{ ok: true, count: 4, pass: 4, plan: { start: 1, end: 4 } }\n```\n\n# usage\n\nThis package also has a `tap-parser` command.\n\n```\nUsage:\n  tap-parser <options>\n\nParses TAP data from stdin, and outputs the parsed result\nin the format specified by the options.  Default output is\nuses node's `util.format()` method.\n\nOptions:\n\n  -j [<indent>] | --json[=indent]\n    Output event data as JSON with the specified indentation (default=2)\n\n  -t | --tap\n    Output data as reconstituted TAP based on parsed results\n\n  -l | --lines\n    Output each parsed line as it is recognized by the parser\n\n  -b | --bail\n    Emit a `Bail out!` at the first failed test point encountered\n\n  -w | --ignore-all-whitespace\n    Skip over blank lines outside of YAML blocks\n\n  -o | --omit-version\n    Ignore the `TAP version 13` line at the start of tests\n```\n\n# methods\n\n``` js\nvar parser = require('tap-parser')\n```\n\n## var p = parser(options, cb)\n\nReturn a writable stream `p` that emits parse events.\n\nIf `cb` is given it will listen for the `'complete'` event.\n\nIf `options` is given, it may contain the following flags:\n\n- `preserveWhitespace` boolean which is `false` by default and will\n  cause the parser to emit `line` events even for lines containing\n  only whitespace.  (Whitespace lines in yaml blocks are always\n  emitted, because whitespace is semantically relevant for yaml.)\n\n- `strict` boolean which is `false` by default and causes the parser\n  to treat non-TAP input as a failure.  Strictness is heritable to\n  child subtests.  You can also turn strictness on or off by using the\n  `pragma +strict` line in the TAP data to turn strictness on, or\n  `pragma -strict` to turn strictness off.\n\n- `bail` boolean which is `false` by default and will cause the parser\n  to bail out (including emitting a synthetic `Bail out!` line)\n  whenever a failed test point is encountered.\n\n- `omitVersion` boolean which is `false` by default and will cause the\n  parser to ignore `TAP version 13` lines.  Version lines in subtests\n  cause problems with some parsers, so they are always ignored.\n\nThe `parent`, `level` and `buffered` options are reserved for internal\nuse.\n\n# events\n\n## p.on('complete', function (results) {})\n\nThe `results` object contains a summary of the number of tests\nskipped, failed, passed, etc., as well as a boolean `ok` member which\nis true if and only if the planned test were all found, and either\n\"ok\" or marked as \"TODO\".\n\n## p.on('line', function (line) {})\n\nAs each line of input is parsed, a `line` event is emitted.  Note\nthat this occurs *before* any other actions based on that line, so\nin some instances, the `line` events will appear to come in advance of\nsomething relating to a previous line.  See `Ordering of Events`\nbelow.\n\n\"Synthetic\" line events will be emitted to support the `bail`\nbehavior, and to inject `1..0` plan lines in subtests that have no\ntest points.  They can be used as a sort of \"passthrough stream\" to\nsanitize and filter a TAP stream, with the caveat that, while `line`\nevents will be semantically equivalent to the TAP input, they will not\nbe a perfect replica of the input.\n\n## p.on('assert', function (assert) {})\n\nEvery `/^(not )?ok\\b/` line will emit an `'assert'` event.\n\nEvery `assert` object has these keys:\n\n* `assert.ok` - true if the assertion succeeded, false if failed\n* `assert.id` - the assertion number\n* `assert.name` - optional short description of the assertion\n\nand may also have\n\n* `assert.todo` - optional description of why the assertion failure is\n  not a problem.  (Boolean `true` if no explaination provided)\n* `assert.skip` - optional description of why this assertion was\n  skipped (boolean `true` if no explanation provided)\n* `assert.diag` - a diagnostic object with additional information\n  about the test point.\n\n## p.on('comment', function (comment) {})\n\nEvery `/^# (.+)/` line will emit the string contents of `comment`.\n\n## p.on('plan', function (plan) {})\n\nEvery `/^\\d+\\.\\.\\d+/` line emits a `'plan'` event for the test numbers\n`plan.start` through `plan.end`, inclusive.\n\nIf the test is [completely\nskipped](http://podwiki.hexten.net/TAP/TAP.html?page=TAP#Skippingeverything)\nthe result will look like\n\n```\n{ ok: true,\n  count: 0,\n  pass: 0,\n  plan:\n   { start: 1,\n     end: 0,\n     skipAll: true,\n     skipReason: 'This code has no seat belt' } }\n```\n\n## p.on('version', function (version) {})\n\nA `/^TAP version (\\d+)/` line emits a `'version'` event with a version\nnumber or string.\n\n## p.on('bailout', function (reason) {})\n\nA `bail out!` line will cause the parser to completely stop doing\nanything.  Child parser bailouts will bail out their parents as well.\n\n## p.on('child', function (childParser) {})\n\nIf a child test set is embedded in the stream like this:\n\n```\nTAP Version 13\n1..2\n# nesting\n    1..2\n    ok 1 - true is ok\n    ok 2 - doag is also okay\nok 1 - nesting\nok 2 - second\n```\n\nthen the child stream will be parsed and events will be raised on the\n`childParser` object.\n\nSince TAP streams with child tests *must* follow child test sets\nwith a pass or fail assert based on the child test's results, failing\nto handle child tests should always result in the same end result.\nHowever, additional information from those child tests will obviously\nbe lost.\n\nSee `Subtests` below for more information on which sorts of subtest\nformats are supported by this parser.\n\n## p.on('extra', function (extra) {})\n\nAll other lines will trigger an `'extra'` event with the line text.\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```\nnpm install tap-parser\n```\n\nYou can use [browserify](http://browserify.org) to `require('tap-parser')` in\nthe browser.\n\n# license\n\nMIT\n\n# subtests\n\n5 flavors of Subtests are suppored by this parser.\n\n1. Unadorned.\n   Indented TAP data with no comment, followed by a test\n   point at the parent level.\n\n    ```\n        ok 1\n        1..1\n    ok 1 - child test\n    1..1\n    ```\n\n2. Indented comment.\n   An indented `# Subtest: <name>` comment, followed by indented TAP\n   data, and then a not-indented test point with a matching name.\n   The summary test point may have yaml diagnostics.\n\n    ```\n        # Subtest: child test\n        ok 1\n        1..1\n    ok 1 - child test\n    1..1\n    ```\n\n3. Unindented comment.\n   A not-indented `# Subtest: <name>` comment, followed by indented TAP\n   content, followed by a test point with a matching name.\n   The summary test point may have yaml diagnostics.\n\n    ```\n    # Subtest: child test\n        ok 1\n        1..1\n    ok 1 - child test\n    1..1\n    ```\n\n4. Buffered, without diagnostics.\n   A test point line ending in {, followed by indented TAP content, ended\n   with a } to close the block.  todo/skip directives may come *either*\n   before or after the `{` character.  Yaml diagnostics are not allowed.\n\n    ```\n    ok 1 - child test {\n        ok 1\n        1..1\n    }\n    1..1\n    ```\n\n5. Buffered, with diagnostics.\n   A test point line with yaml diagnostics, followed by `{` alone on a\n   line, indented TAP data, and then a `}`.\n\n    ```\n    ok 1 - child test\n      ---\n      some: diagnostic\n      data: true\n      ...\n    {\n        ok 1\n        1..1\n    }\n    ```\n\nIn all cases, the parsed behavior is identical:\n\n1. The parent emits a `child` event with the `childParser` as an\n   argument.\n2. The `childParser` emits a `comment` with `# Subtest: <name>` (or\n   `(anonymous)` for Unadorned subtests.)\n3. When the test is over, the closing test point is emitted on parent\n   test.\n\nThat is, buffered and nonindented/indented comment subtests are parsed\nas if they are identical input, since their semantics are the same.  This\nsimplifies implementation of test harness and reporter modules.\n\nSince unadorned subtests have no introduction, a child event is not\nemitted until the first \"relevant tap\" line is encountered.  This can\ncause confusion if the test output contains a spurious \"    1..2\" line\nor something, but such cases are rare.\n\nSimilarly, this means that a test point ending in `{` needs to wait to\nemit *either* the 'assert' or 'child' events until an indented line is\nencountered.  *Any* test point with yaml diagnostics needs to wait to\nsee if it will be followed by a `{` indicating a subtest.  This has an\neffect on the specific ordering of `assert` and `child` events with\nrespect to the `line` events.\n\n# Ordering of Events\n\nWhile TAP is *mostly* parseable in a deterministically line-by-line\nfashion, subtests and yaml diagnostics require that the parser analyze\nthe next line before making a decision in some cases about what event\nto emit.\n\nFor example:\n\n```tap\nok 1 - this is fine\n  ---\n  some: diags\n  ...\n1..1\n```\n\nThe parser will emit the following events in this order:\n\n```\nline \"ok 1 - this is fine\\n\"\nline \"  ---\\n\"\nline \"  some: diags\\n\"\nline \"  ...\\n\"\nline \"1..1\\n\"\nassert {\"ok\":true,\"id\":1,\"name\":\"this is fine\",\"diag\":{\"some\":\"diags\"}}\nplan {\"start\":1,\"end\":1}\ncomplete {\"ok\":true,\"count\":1,\"pass\":1,\"plan\":{\"start\":1,\"end\":1}}\n```\n\nThe `1..1` line comes *ahead* of the `assert` event, because it's not\nuntil that line is encountered that the parser knows that the assert\nis completed, and not the introduction of a subtest.\n\nAnother interesting case is comments that may occur within a yaml\ndiagnostic block.  In this case, the comments are held until _after_\nthe `assert` event, even though the technically occur while the test\npoint is being parsed.\n\n```tap\nok 1 - this is fine\n# before the yaml\n  ---\n  # just a comment\n  some: diags\n# nothing to worry about\n  ...\n# more commentary\n1..1\n```\n\nIn this case, the events will be emitted in this order:\n\n```\nline \"ok 1 - this is fine\\n\"\nline \"# before the yaml\\n\"\nline \"  ---\\n\"\nline \"  # just a comment\\n\"\nline \"  some: diags\\n\"\nline \"# nothing to worry about\\n\"\nline \"  ...\\n\"\nline \"# more commentary\\n\"\nline \"1..1\\n\"\nassert {\"ok\":true,\"id\":1,\"name\":\"this is fine\",\"diag\":{\"some\":\"diags\"}}\ncomment \"# before the yaml\\n\"\ncomment \"  # just a comment\\n\"\ncomment \"# nothing to worry about\\n\"\ncomment \"# more commentary\\n\"\nplan {\"start\":1,\"end\":1}\ncomplete {\"ok\":true,\"count\":1,\"pass\":1,\"plan\":{\"start\":1,\"end\":1}}\n```\n",
  "readmeFilename": "readme.markdown",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/tap-parser.git"
  },
  "scripts": {
    "preversion": "npm test",
    "regen-fixtures": "node scripts/generate-test.js test/fixtures/*.tap",
    "test": "tap test/*.js --100"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/6..latest",
      "chrome/10",
      "chrome/latest",
      "firefox/3.5",
      "firefox/latest",
      "opera/latest",
      "safari/latest"
    ]
  },
  "version": "4.2.4"
}
